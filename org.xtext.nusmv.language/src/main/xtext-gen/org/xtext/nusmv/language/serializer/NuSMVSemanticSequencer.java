/*
 * generated by Xtext 2.21.0
 */
package org.xtext.nusmv.language.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.nusmv.language.nuSMV.ArrayType;
import org.xtext.nusmv.language.nuSMV.AssignConstraintElement;
import org.xtext.nusmv.language.nuSMV.AsyncrProcessType;
import org.xtext.nusmv.language.nuSMV.BinaryExpression;
import org.xtext.nusmv.language.nuSMV.BooleanType;
import org.xtext.nusmv.language.nuSMV.CTLExpression;
import org.xtext.nusmv.language.nuSMV.CaseSimpleAssignementExpression;
import org.xtext.nusmv.language.nuSMV.CaseSimpleExpression;
import org.xtext.nusmv.language.nuSMV.CompassionExpression;
import org.xtext.nusmv.language.nuSMV.ComputeSpecification;
import org.xtext.nusmv.language.nuSMV.ConstantsDeclaration;
import org.xtext.nusmv.language.nuSMV.CtlSpecification;
import org.xtext.nusmv.language.nuSMV.DefineBody;
import org.xtext.nusmv.language.nuSMV.DefineDeclaration;
import org.xtext.nusmv.language.nuSMV.EnumType;
import org.xtext.nusmv.language.nuSMV.FairnessExpression;
import org.xtext.nusmv.language.nuSMV.FormalParameter;
import org.xtext.nusmv.language.nuSMV.FrozenVariableDeclaration;
import org.xtext.nusmv.language.nuSMV.IVariableDeclaration;
import org.xtext.nusmv.language.nuSMV.InitBody;
import org.xtext.nusmv.language.nuSMV.InitConstraint;
import org.xtext.nusmv.language.nuSMV.IntervalExpression;
import org.xtext.nusmv.language.nuSMV.IntervalType;
import org.xtext.nusmv.language.nuSMV.InvarConstraint;
import org.xtext.nusmv.language.nuSMV.InvarSpecification;
import org.xtext.nusmv.language.nuSMV.IsaDeclaration;
import org.xtext.nusmv.language.nuSMV.JusticeExpression;
import org.xtext.nusmv.language.nuSMV.LTLExpression;
import org.xtext.nusmv.language.nuSMV.LtlSpecification;
import org.xtext.nusmv.language.nuSMV.NextBody;
import org.xtext.nusmv.language.nuSMV.NextExpression;
import org.xtext.nusmv.language.nuSMV.Not;
import org.xtext.nusmv.language.nuSMV.NuSMVPackage;
import org.xtext.nusmv.language.nuSMV.NuSmvModel;
import org.xtext.nusmv.language.nuSMV.PSLExpression;
import org.xtext.nusmv.language.nuSMV.ParsExpression;
import org.xtext.nusmv.language.nuSMV.PslSpecification;
import org.xtext.nusmv.language.nuSMV.RangeExpression;
import org.xtext.nusmv.language.nuSMV.SetElementExpression;
import org.xtext.nusmv.language.nuSMV.SetExpression;
import org.xtext.nusmv.language.nuSMV.SetValueParameter;
import org.xtext.nusmv.language.nuSMV.SignedWordType;
import org.xtext.nusmv.language.nuSMV.SingleRTCTLExpression;
import org.xtext.nusmv.language.nuSMV.SyncrProcessType;
import org.xtext.nusmv.language.nuSMV.ToInt;
import org.xtext.nusmv.language.nuSMV.TransConstraint;
import org.xtext.nusmv.language.nuSMV.UnaryExpression;
import org.xtext.nusmv.language.nuSMV.UnaryFunctionExpression;
import org.xtext.nusmv.language.nuSMV.UnaryRTCTLExpression;
import org.xtext.nusmv.language.nuSMV.UnsignedWordType;
import org.xtext.nusmv.language.nuSMV.UntilCTLexpression;
import org.xtext.nusmv.language.nuSMV.Val;
import org.xtext.nusmv.language.nuSMV.ValueExpression;
import org.xtext.nusmv.language.nuSMV.Var;
import org.xtext.nusmv.language.nuSMV.VarBody;
import org.xtext.nusmv.language.nuSMV.VarBodyAssign;
import org.xtext.nusmv.language.nuSMV.VariableDeclaration;
import org.xtext.nusmv.language.nuSMV.WordExpression;
import org.xtext.nusmv.language.nuSMV.WordType;
import org.xtext.nusmv.language.services.NuSMVGrammarAccess;

@SuppressWarnings("all")
public class NuSMVSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private NuSMVGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == NuSMVPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case NuSMVPackage.ARRAY_TYPE:
				sequence_SimpleType(context, (ArrayType) semanticObject); 
				return; 
			case NuSMVPackage.ASSIGN_CONSTRAINT_ELEMENT:
				sequence_AssignConstraint(context, (AssignConstraintElement) semanticObject); 
				return; 
			case NuSMVPackage.ASYNCR_PROCESS_TYPE:
				sequence_ModuleType(context, (AsyncrProcessType) semanticObject); 
				return; 
			case NuSMVPackage.BINARY_EXPRESSION:
				if (rule == grammarAccess.getSimpleExpressionRule()
						|| rule == grammarAccess.getLTLbinExpressionRule()
						|| action == grammarAccess.getLTLbinExpressionAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_AndExpression_ComparisonExpression_Div_IffExpression_ImpliesExpression_InExpression_LTLbinExpression_LeftShift_Minus_Mod_Mult_OrExpression_Plus_RightShift_UnionExpression_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getImpliesExpressionRule()
						|| action == grammarAccess.getImpliesExpressionAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_AndExpression_ComparisonExpression_Div_IffExpression_ImpliesExpression_InExpression_LeftShift_Minus_Mod_Mult_OrExpression_Plus_RightShift_UnionExpression_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIffExpressionRule()
						|| action == grammarAccess.getIffExpressionAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_AndExpression_ComparisonExpression_Div_IffExpression_InExpression_LeftShift_Minus_Mod_Mult_OrExpression_Plus_RightShift_UnionExpression_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_AndExpression_ComparisonExpression_Div_InExpression_LeftShift_Minus_Mod_Mult_OrExpression_Plus_RightShift_UnionExpression_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_AndExpression_ComparisonExpression_Div_InExpression_LeftShift_Minus_Mod_Mult_Plus_RightShift_UnionExpression_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_ComparisonExpression_Div_InExpression_LeftShift_Minus_Mod_Mult_Plus_RightShift_UnionExpression_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDivRule()
						|| action == grammarAccess.getDivAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_Div(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getInExpressionRule()
						|| action == grammarAccess.getInExpressionAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_Div_InExpression_LeftShift_Minus_Mod_Mult_Plus_RightShift_UnionExpression_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnionExpressionRule()
						|| action == grammarAccess.getUnionExpressionAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_Div_LeftShift_Minus_Mod_Mult_Plus_RightShift_UnionExpression_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRightShiftRule()
						|| action == grammarAccess.getRightShiftAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_Div_LeftShift_Minus_Mod_Mult_Plus_RightShift_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLeftShiftRule()
						|| action == grammarAccess.getLeftShiftAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_Div_LeftShift_Minus_Mod_Mult_Plus_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMinusRule()
						|| action == grammarAccess.getMinusAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_Div_Minus_Mod_Mult_Plus_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPlusRule()
						|| action == grammarAccess.getPlusAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_Div_Mod_Mult_Plus_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultRule()
						|| action == grammarAccess.getMultAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_Div_Mod_Mult_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getModRule()
						|| action == grammarAccess.getModAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_Div_Mod_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWordConcatenationRule()
						|| action == grammarAccess.getWordConcatenationAccess().getBinaryExpressionLeftAction_1_0()) {
					sequence_Div_WordConcatenation(context, (BinaryExpression) semanticObject); 
					return; 
				}
				else break;
			case NuSMVPackage.BOOLEAN_TYPE:
				sequence_SimpleType(context, (BooleanType) semanticObject); 
				return; 
			case NuSMVPackage.CTL_EXPRESSION:
				sequence_CTLExpression(context, (CTLExpression) semanticObject); 
				return; 
			case NuSMVPackage.CASE_SIMPLE_ASSIGNEMENT_EXPRESSION:
				sequence_CaseSimpleAssignementExpression(context, (CaseSimpleAssignementExpression) semanticObject); 
				return; 
			case NuSMVPackage.CASE_SIMPLE_EXPRESSION:
				sequence_CaseSimpleExpression(context, (CaseSimpleExpression) semanticObject); 
				return; 
			case NuSMVPackage.COMPASSION_EXPRESSION:
				sequence_CompassionExpression(context, (CompassionExpression) semanticObject); 
				return; 
			case NuSMVPackage.COMPUTE_SPECIFICATION:
				sequence_ComputeSpecification(context, (ComputeSpecification) semanticObject); 
				return; 
			case NuSMVPackage.CONSTANTS_DECLARATION:
				sequence_ConstantsDeclaration(context, (ConstantsDeclaration) semanticObject); 
				return; 
			case NuSMVPackage.CTL_SPECIFICATION:
				sequence_CtlSpecification(context, (CtlSpecification) semanticObject); 
				return; 
			case NuSMVPackage.DEFINE_BODY:
				sequence_DefineBody(context, (DefineBody) semanticObject); 
				return; 
			case NuSMVPackage.DEFINE_DECLARATION:
				sequence_DefineDeclaration(context, (DefineDeclaration) semanticObject); 
				return; 
			case NuSMVPackage.ENUM_TYPE:
				sequence_SimpleType(context, (EnumType) semanticObject); 
				return; 
			case NuSMVPackage.FAIRNESS_EXPRESSION:
				sequence_FairnessExpression(context, (FairnessExpression) semanticObject); 
				return; 
			case NuSMVPackage.FORMAL_PARAMETER:
				sequence_FormalParameter(context, (FormalParameter) semanticObject); 
				return; 
			case NuSMVPackage.FROZEN_VARIABLE_DECLARATION:
				sequence_FrozenVariableDeclaration(context, (FrozenVariableDeclaration) semanticObject); 
				return; 
			case NuSMVPackage.IVARIABLE_DECLARATION:
				sequence_IVariableDeclaration(context, (IVariableDeclaration) semanticObject); 
				return; 
			case NuSMVPackage.INIT_BODY:
				sequence_InitBody(context, (InitBody) semanticObject); 
				return; 
			case NuSMVPackage.INIT_CONSTRAINT:
				sequence_InitConstraint(context, (InitConstraint) semanticObject); 
				return; 
			case NuSMVPackage.INTERVAL_EXPRESSION:
				sequence_TerminalSimpleExpression(context, (IntervalExpression) semanticObject); 
				return; 
			case NuSMVPackage.INTERVAL_TYPE:
				sequence_SimpleType(context, (IntervalType) semanticObject); 
				return; 
			case NuSMVPackage.INVAR_CONSTRAINT:
				sequence_InvarConstraint(context, (InvarConstraint) semanticObject); 
				return; 
			case NuSMVPackage.INVAR_SPECIFICATION:
				sequence_InvarSpecification(context, (InvarSpecification) semanticObject); 
				return; 
			case NuSMVPackage.ISA_DECLARATION:
				sequence_IsaDeclaration(context, (IsaDeclaration) semanticObject); 
				return; 
			case NuSMVPackage.JUSTICE_EXPRESSION:
				sequence_JusticeExpression(context, (JusticeExpression) semanticObject); 
				return; 
			case NuSMVPackage.LTL_EXPRESSION:
				sequence_LTLExpression(context, (LTLExpression) semanticObject); 
				return; 
			case NuSMVPackage.LTL_SPECIFICATION:
				sequence_LtlSpecification(context, (LtlSpecification) semanticObject); 
				return; 
			case NuSMVPackage.MODULE:
				sequence_Module(context, (org.xtext.nusmv.language.nuSMV.Module) semanticObject); 
				return; 
			case NuSMVPackage.NEXT_BODY:
				sequence_NextBody(context, (NextBody) semanticObject); 
				return; 
			case NuSMVPackage.NEXT_EXPRESSION:
				sequence_NextExpression(context, (NextExpression) semanticObject); 
				return; 
			case NuSMVPackage.NOT:
				sequence_NotOrTerminalSimpleExpression(context, (Not) semanticObject); 
				return; 
			case NuSMVPackage.NU_SMV_MODEL:
				sequence_NuSmvModel(context, (NuSmvModel) semanticObject); 
				return; 
			case NuSMVPackage.PSL_EXPRESSION:
				sequence_PSLExpression(context, (PSLExpression) semanticObject); 
				return; 
			case NuSMVPackage.PARS_EXPRESSION:
				sequence_TerminalSimpleExpression(context, (ParsExpression) semanticObject); 
				return; 
			case NuSMVPackage.PSL_SPECIFICATION:
				sequence_PslSpecification(context, (PslSpecification) semanticObject); 
				return; 
			case NuSMVPackage.RANGE_EXPRESSION:
				sequence_RangeExpression(context, (RangeExpression) semanticObject); 
				return; 
			case NuSMVPackage.SET_ELEMENT_EXPRESSION:
				sequence_TerminalSimpleExpression(context, (SetElementExpression) semanticObject); 
				return; 
			case NuSMVPackage.SET_EXPRESSION:
				sequence_TerminalSimpleExpression(context, (SetExpression) semanticObject); 
				return; 
			case NuSMVPackage.SET_VALUE_PARAMETER:
				sequence_TerminalSimpleExpression(context, (SetValueParameter) semanticObject); 
				return; 
			case NuSMVPackage.SIGNED_WORD_TYPE:
				sequence_SimpleType(context, (SignedWordType) semanticObject); 
				return; 
			case NuSMVPackage.SINGLE_RTCTL_EXPRESSION:
				sequence_RTCTLExpression(context, (SingleRTCTLExpression) semanticObject); 
				return; 
			case NuSMVPackage.SYNCR_PROCESS_TYPE:
				sequence_ModuleType(context, (SyncrProcessType) semanticObject); 
				return; 
			case NuSMVPackage.TO_INT:
				sequence_TerminalSimpleExpression(context, (ToInt) semanticObject); 
				return; 
			case NuSMVPackage.TRANS_CONSTRAINT:
				sequence_TransConstraint(context, (TransConstraint) semanticObject); 
				return; 
			case NuSMVPackage.UNARY_EXPRESSION:
				sequence_TerminalSimpleExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case NuSMVPackage.UNARY_FUNCTION_EXPRESSION:
				sequence_TerminalSimpleExpression(context, (UnaryFunctionExpression) semanticObject); 
				return; 
			case NuSMVPackage.UNARY_RTCTL_EXPRESSION:
				sequence_RTCTLExpression(context, (UnaryRTCTLExpression) semanticObject); 
				return; 
			case NuSMVPackage.UNSIGNED_WORD_TYPE:
				sequence_SimpleType(context, (UnsignedWordType) semanticObject); 
				return; 
			case NuSMVPackage.UNTIL_CT_LEXPRESSION:
				sequence_TerminalSimpleExpression(context, (UntilCTLexpression) semanticObject); 
				return; 
			case NuSMVPackage.VAL:
				sequence_Val(context, (Val) semanticObject); 
				return; 
			case NuSMVPackage.VALUE_EXPRESSION:
				sequence_TerminalSimpleExpression(context, (ValueExpression) semanticObject); 
				return; 
			case NuSMVPackage.VAR:
				sequence_TerminalSimpleExpression(context, (Var) semanticObject); 
				return; 
			case NuSMVPackage.VAR_BODY:
				sequence_VarBody(context, (VarBody) semanticObject); 
				return; 
			case NuSMVPackage.VAR_BODY_ASSIGN:
				sequence_VarBodyAssign(context, (VarBodyAssign) semanticObject); 
				return; 
			case NuSMVPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case NuSMVPackage.WORD_EXPRESSION:
				sequence_TerminalSimpleExpression(context, (WordExpression) semanticObject); 
				return; 
			case NuSMVPackage.WORD_TYPE:
				sequence_SimpleType(context, (WordType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     SimpleExpression returns BinaryExpression
	 *     LTLbinExpression returns BinaryExpression
	 *     LTLbinExpression.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=LTLbinExpression_BinaryExpression_1_0 operator=LTLbinoperators right=ImpliesExpression) | 
	 *         (left=ImpliesExpression_BinaryExpression_1_0 operator=impliesoperator right=IffExpression) | 
	 *         (left=IffExpression_BinaryExpression_1_0 operator=iffoperator right=OrExpression) | 
	 *         (left=OrExpression_BinaryExpression_1_0 operator=oroperators right=AndExpression) | 
	 *         (left=AndExpression_BinaryExpression_1_0 operator=andoperator right=ComparisonExpression) | 
	 *         (left=ComparisonExpression_BinaryExpression_1_0 operator=comparisonoperators right=InExpression) | 
	 *         (left=InExpression_BinaryExpression_1_0 op='in' right=UnionExpression) | 
	 *         (left=UnionExpression_BinaryExpression_1_0 op='union' right=RightShift) | 
	 *         (left=RightShift_BinaryExpression_1_0 op='>>' right=LeftShift) | 
	 *         (left=LeftShift_BinaryExpression_1_0 op='<<' right=Minus) | 
	 *         (left=Minus_BinaryExpression_1_0 op='-' right=Plus) | 
	 *         (left=Plus_BinaryExpression_1_0 op='+' right=Mult) | 
	 *         (left=Mult_BinaryExpression_1_0 op='*' right=Mod) | 
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_AndExpression_ComparisonExpression_Div_IffExpression_ImpliesExpression_InExpression_LTLbinExpression_LeftShift_Minus_Mod_Mult_OrExpression_Plus_RightShift_UnionExpression_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImpliesExpression returns BinaryExpression
	 *     ImpliesExpression.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=ImpliesExpression_BinaryExpression_1_0 operator=impliesoperator right=IffExpression) | 
	 *         (left=IffExpression_BinaryExpression_1_0 operator=iffoperator right=OrExpression) | 
	 *         (left=OrExpression_BinaryExpression_1_0 operator=oroperators right=AndExpression) | 
	 *         (left=AndExpression_BinaryExpression_1_0 operator=andoperator right=ComparisonExpression) | 
	 *         (left=ComparisonExpression_BinaryExpression_1_0 operator=comparisonoperators right=InExpression) | 
	 *         (left=InExpression_BinaryExpression_1_0 op='in' right=UnionExpression) | 
	 *         (left=UnionExpression_BinaryExpression_1_0 op='union' right=RightShift) | 
	 *         (left=RightShift_BinaryExpression_1_0 op='>>' right=LeftShift) | 
	 *         (left=LeftShift_BinaryExpression_1_0 op='<<' right=Minus) | 
	 *         (left=Minus_BinaryExpression_1_0 op='-' right=Plus) | 
	 *         (left=Plus_BinaryExpression_1_0 op='+' right=Mult) | 
	 *         (left=Mult_BinaryExpression_1_0 op='*' right=Mod) | 
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_AndExpression_ComparisonExpression_Div_IffExpression_ImpliesExpression_InExpression_LeftShift_Minus_Mod_Mult_OrExpression_Plus_RightShift_UnionExpression_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IffExpression returns BinaryExpression
	 *     IffExpression.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=IffExpression_BinaryExpression_1_0 operator=iffoperator right=OrExpression) | 
	 *         (left=OrExpression_BinaryExpression_1_0 operator=oroperators right=AndExpression) | 
	 *         (left=AndExpression_BinaryExpression_1_0 operator=andoperator right=ComparisonExpression) | 
	 *         (left=ComparisonExpression_BinaryExpression_1_0 operator=comparisonoperators right=InExpression) | 
	 *         (left=InExpression_BinaryExpression_1_0 op='in' right=UnionExpression) | 
	 *         (left=UnionExpression_BinaryExpression_1_0 op='union' right=RightShift) | 
	 *         (left=RightShift_BinaryExpression_1_0 op='>>' right=LeftShift) | 
	 *         (left=LeftShift_BinaryExpression_1_0 op='<<' right=Minus) | 
	 *         (left=Minus_BinaryExpression_1_0 op='-' right=Plus) | 
	 *         (left=Plus_BinaryExpression_1_0 op='+' right=Mult) | 
	 *         (left=Mult_BinaryExpression_1_0 op='*' right=Mod) | 
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_AndExpression_ComparisonExpression_Div_IffExpression_InExpression_LeftShift_Minus_Mod_Mult_OrExpression_Plus_RightShift_UnionExpression_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrExpression returns BinaryExpression
	 *     OrExpression.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=OrExpression_BinaryExpression_1_0 operator=oroperators right=AndExpression) | 
	 *         (left=AndExpression_BinaryExpression_1_0 operator=andoperator right=ComparisonExpression) | 
	 *         (left=ComparisonExpression_BinaryExpression_1_0 operator=comparisonoperators right=InExpression) | 
	 *         (left=InExpression_BinaryExpression_1_0 op='in' right=UnionExpression) | 
	 *         (left=UnionExpression_BinaryExpression_1_0 op='union' right=RightShift) | 
	 *         (left=RightShift_BinaryExpression_1_0 op='>>' right=LeftShift) | 
	 *         (left=LeftShift_BinaryExpression_1_0 op='<<' right=Minus) | 
	 *         (left=Minus_BinaryExpression_1_0 op='-' right=Plus) | 
	 *         (left=Plus_BinaryExpression_1_0 op='+' right=Mult) | 
	 *         (left=Mult_BinaryExpression_1_0 op='*' right=Mod) | 
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_AndExpression_ComparisonExpression_Div_InExpression_LeftShift_Minus_Mod_Mult_OrExpression_Plus_RightShift_UnionExpression_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndExpression returns BinaryExpression
	 *     AndExpression.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=AndExpression_BinaryExpression_1_0 operator=andoperator right=ComparisonExpression) | 
	 *         (left=ComparisonExpression_BinaryExpression_1_0 operator=comparisonoperators right=InExpression) | 
	 *         (left=InExpression_BinaryExpression_1_0 op='in' right=UnionExpression) | 
	 *         (left=UnionExpression_BinaryExpression_1_0 op='union' right=RightShift) | 
	 *         (left=RightShift_BinaryExpression_1_0 op='>>' right=LeftShift) | 
	 *         (left=LeftShift_BinaryExpression_1_0 op='<<' right=Minus) | 
	 *         (left=Minus_BinaryExpression_1_0 op='-' right=Plus) | 
	 *         (left=Plus_BinaryExpression_1_0 op='+' right=Mult) | 
	 *         (left=Mult_BinaryExpression_1_0 op='*' right=Mod) | 
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_AndExpression_ComparisonExpression_Div_InExpression_LeftShift_Minus_Mod_Mult_Plus_RightShift_UnionExpression_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns AssignConstraintElement
	 *     AssignConstraint returns AssignConstraintElement
	 *
	 * Constraint:
	 *     (assign='ASSIGN' bodies+=AssignBody*)
	 */
	protected void sequence_AssignConstraint(ISerializationContext context, AssignConstraintElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CTLExpression returns CTLExpression
	 *
	 * Constraint:
	 *     simpleExpression=SimpleExpression
	 */
	protected void sequence_CTLExpression(ISerializationContext context, CTLExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.CTL_EXPRESSION__SIMPLE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.CTL_EXPRESSION__SIMPLE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCTLExpressionAccess().getSimpleExpressionSimpleExpressionParserRuleCall_0(), semanticObject.getSimpleExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseSimpleAssignementExpression returns CaseSimpleAssignementExpression
	 *
	 * Constraint:
	 *     (case=SimpleExpression assignment=SimpleExpression)
	 */
	protected void sequence_CaseSimpleAssignementExpression(ISerializationContext context, CaseSimpleAssignementExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.CASE_SIMPLE_ASSIGNEMENT_EXPRESSION__CASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.CASE_SIMPLE_ASSIGNEMENT_EXPRESSION__CASE));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.CASE_SIMPLE_ASSIGNEMENT_EXPRESSION__ASSIGNMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.CASE_SIMPLE_ASSIGNEMENT_EXPRESSION__ASSIGNMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseSimpleAssignementExpressionAccess().getCaseSimpleExpressionParserRuleCall_0_0(), semanticObject.getCase());
		feeder.accept(grammarAccess.getCaseSimpleAssignementExpressionAccess().getAssignmentSimpleExpressionParserRuleCall_2_0(), semanticObject.getAssignment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns CaseSimpleExpression
	 *     LTLbinExpression returns CaseSimpleExpression
	 *     LTLbinExpression.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     ImpliesExpression returns CaseSimpleExpression
	 *     ImpliesExpression.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     IffExpression returns CaseSimpleExpression
	 *     IffExpression.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     OrExpression returns CaseSimpleExpression
	 *     OrExpression.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     AndExpression returns CaseSimpleExpression
	 *     AndExpression.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     ComparisonExpression returns CaseSimpleExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     InExpression returns CaseSimpleExpression
	 *     InExpression.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     UnionExpression returns CaseSimpleExpression
	 *     UnionExpression.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     RightShift returns CaseSimpleExpression
	 *     RightShift.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     LeftShift returns CaseSimpleExpression
	 *     LeftShift.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     Minus returns CaseSimpleExpression
	 *     Minus.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     Plus returns CaseSimpleExpression
	 *     Plus.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     Mult returns CaseSimpleExpression
	 *     Mult.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     Mod returns CaseSimpleExpression
	 *     Mod.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     WordConcatenation returns CaseSimpleExpression
	 *     WordConcatenation.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     Div returns CaseSimpleExpression
	 *     Div.BinaryExpression_1_0 returns CaseSimpleExpression
	 *     NotOrTerminalSimpleExpression returns CaseSimpleExpression
	 *     TerminalSimpleExpression returns CaseSimpleExpression
	 *     CaseSimpleExpression returns CaseSimpleExpression
	 *
	 * Constraint:
	 *     branches+=CaseSimpleAssignementExpression+
	 */
	protected void sequence_CaseSimpleExpression(ISerializationContext context, CaseSimpleExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComparisonExpression returns BinaryExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=ComparisonExpression_BinaryExpression_1_0 operator=comparisonoperators right=InExpression) | 
	 *         (left=InExpression_BinaryExpression_1_0 op='in' right=UnionExpression) | 
	 *         (left=UnionExpression_BinaryExpression_1_0 op='union' right=RightShift) | 
	 *         (left=RightShift_BinaryExpression_1_0 op='>>' right=LeftShift) | 
	 *         (left=LeftShift_BinaryExpression_1_0 op='<<' right=Minus) | 
	 *         (left=Minus_BinaryExpression_1_0 op='-' right=Plus) | 
	 *         (left=Plus_BinaryExpression_1_0 op='+' right=Mult) | 
	 *         (left=Mult_BinaryExpression_1_0 op='*' right=Mod) | 
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_ComparisonExpression_Div_InExpression_LeftShift_Minus_Mod_Mult_Plus_RightShift_UnionExpression_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns CompassionExpression
	 *     FairnessConstraint returns CompassionExpression
	 *     CompassionExpression returns CompassionExpression
	 *
	 * Constraint:
	 *     (firstExpr=SimpleExpression secondExpr=SimpleExpression semicolon?=';'?)
	 */
	protected void sequence_CompassionExpression(ISerializationContext context, CompassionExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns ComputeSpecification
	 *     ComputeSpecification returns ComputeSpecification
	 *
	 * Constraint:
	 *     ((minMax='MIN' | minMax='MAX') first=RTCTLExpression second=RTCTLExpression semicolon?=';'?)
	 */
	protected void sequence_ComputeSpecification(ISerializationContext context, ComputeSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns ConstantsDeclaration
	 *     ConstantsDeclaration returns ConstantsDeclaration
	 *
	 * Constraint:
	 *     (constants+=ID constants+=ID* semicolon?=';')
	 */
	protected void sequence_ConstantsDeclaration(ISerializationContext context, ConstantsDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns CtlSpecification
	 *     CtlSpecification returns CtlSpecification
	 *
	 * Constraint:
	 *     ((specKeyWord='CTLSPEC' | specKeyWord='SPEC') (nameKeyWord?='NAME' name=ID)? ctlExpression=CTLExpression semicolon?=';'?)
	 */
	protected void sequence_CtlSpecification(ISerializationContext context, CtlSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefineBody returns DefineBody
	 *
	 * Constraint:
	 *     (var=ID assignment=SimpleExpression semicolon?=';')
	 */
	protected void sequence_DefineBody(ISerializationContext context, DefineBody semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.DEFINE_BODY__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.DEFINE_BODY__VAR));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.DEFINE_BODY__ASSIGNMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.DEFINE_BODY__ASSIGNMENT));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.DEFINE_BODY__SEMICOLON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.DEFINE_BODY__SEMICOLON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefineBodyAccess().getVarIDTerminalRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getDefineBodyAccess().getAssignmentSimpleExpressionParserRuleCall_2_0(), semanticObject.getAssignment());
		feeder.accept(grammarAccess.getDefineBodyAccess().getSemicolonSemicolonKeyword_3_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns DefineDeclaration
	 *     DefineDeclaration returns DefineDeclaration
	 *
	 * Constraint:
	 *     (define='DEFINE' defineBodies+=DefineBody*)
	 */
	protected void sequence_DefineDeclaration(ISerializationContext context, DefineDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Div returns BinaryExpression
	 *     Div.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 */
	protected void sequence_Div(ISerializationContext context, BinaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.BINARY_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.BINARY_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.BINARY_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.BINARY_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.BINARY_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.BINARY_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivAccess().getBinaryExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDivAccess().getOpSolidusKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getDivAccess().getRightNotOrTerminalSimpleExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InExpression returns BinaryExpression
	 *     InExpression.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=InExpression_BinaryExpression_1_0 op='in' right=UnionExpression) | 
	 *         (left=UnionExpression_BinaryExpression_1_0 op='union' right=RightShift) | 
	 *         (left=RightShift_BinaryExpression_1_0 op='>>' right=LeftShift) | 
	 *         (left=LeftShift_BinaryExpression_1_0 op='<<' right=Minus) | 
	 *         (left=Minus_BinaryExpression_1_0 op='-' right=Plus) | 
	 *         (left=Plus_BinaryExpression_1_0 op='+' right=Mult) | 
	 *         (left=Mult_BinaryExpression_1_0 op='*' right=Mod) | 
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_Div_InExpression_LeftShift_Minus_Mod_Mult_Plus_RightShift_UnionExpression_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnionExpression returns BinaryExpression
	 *     UnionExpression.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=UnionExpression_BinaryExpression_1_0 op='union' right=RightShift) | 
	 *         (left=RightShift_BinaryExpression_1_0 op='>>' right=LeftShift) | 
	 *         (left=LeftShift_BinaryExpression_1_0 op='<<' right=Minus) | 
	 *         (left=Minus_BinaryExpression_1_0 op='-' right=Plus) | 
	 *         (left=Plus_BinaryExpression_1_0 op='+' right=Mult) | 
	 *         (left=Mult_BinaryExpression_1_0 op='*' right=Mod) | 
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_Div_LeftShift_Minus_Mod_Mult_Plus_RightShift_UnionExpression_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RightShift returns BinaryExpression
	 *     RightShift.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=RightShift_BinaryExpression_1_0 op='>>' right=LeftShift) | 
	 *         (left=LeftShift_BinaryExpression_1_0 op='<<' right=Minus) | 
	 *         (left=Minus_BinaryExpression_1_0 op='-' right=Plus) | 
	 *         (left=Plus_BinaryExpression_1_0 op='+' right=Mult) | 
	 *         (left=Mult_BinaryExpression_1_0 op='*' right=Mod) | 
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_Div_LeftShift_Minus_Mod_Mult_Plus_RightShift_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LeftShift returns BinaryExpression
	 *     LeftShift.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=LeftShift_BinaryExpression_1_0 op='<<' right=Minus) | 
	 *         (left=Minus_BinaryExpression_1_0 op='-' right=Plus) | 
	 *         (left=Plus_BinaryExpression_1_0 op='+' right=Mult) | 
	 *         (left=Mult_BinaryExpression_1_0 op='*' right=Mod) | 
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_Div_LeftShift_Minus_Mod_Mult_Plus_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Minus returns BinaryExpression
	 *     Minus.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=Minus_BinaryExpression_1_0 op='-' right=Plus) | 
	 *         (left=Plus_BinaryExpression_1_0 op='+' right=Mult) | 
	 *         (left=Mult_BinaryExpression_1_0 op='*' right=Mod) | 
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_Div_Minus_Mod_Mult_Plus_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Plus returns BinaryExpression
	 *     Plus.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=Plus_BinaryExpression_1_0 op='+' right=Mult) | 
	 *         (left=Mult_BinaryExpression_1_0 op='*' right=Mod) | 
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_Div_Mod_Mult_Plus_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Mult returns BinaryExpression
	 *     Mult.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=Mult_BinaryExpression_1_0 op='*' right=Mod) | 
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_Div_Mod_Mult_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Mod returns BinaryExpression
	 *     Mod.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=Mod_BinaryExpression_1_0 op='mod' right=WordConcatenation) | 
	 *         (left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | 
	 *         (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression)
	 *     )
	 */
	protected void sequence_Div_Mod_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WordConcatenation returns BinaryExpression
	 *     WordConcatenation.BinaryExpression_1_0 returns BinaryExpression
	 *
	 * Constraint:
	 *     ((left=WordConcatenation_BinaryExpression_1_0 op='::' right=Div) | (left=Div_BinaryExpression_1_0 op='/' right=NotOrTerminalSimpleExpression))
	 */
	protected void sequence_Div_WordConcatenation(ISerializationContext context, BinaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns FairnessExpression
	 *     FairnessConstraint returns FairnessExpression
	 *     FairnessExpression returns FairnessExpression
	 *
	 * Constraint:
	 *     (fairnessExpr=SimpleExpression semicolon?=';'?)
	 */
	protected void sequence_FairnessExpression(ISerializationContext context, FairnessExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormalParameter returns FormalParameter
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_FormalParameter(ISerializationContext context, FormalParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.FORMAL_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.FORMAL_PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFormalParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns FrozenVariableDeclaration
	 *     FrozenVariableDeclaration returns FrozenVariableDeclaration
	 *
	 * Constraint:
	 *     vars+=VarBody+
	 */
	protected void sequence_FrozenVariableDeclaration(ISerializationContext context, FrozenVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns IVariableDeclaration
	 *     IVariableDeclaration returns IVariableDeclaration
	 *
	 * Constraint:
	 *     vars+=VarBody+
	 */
	protected void sequence_IVariableDeclaration(ISerializationContext context, IVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssignBody returns InitBody
	 *     InitBody returns InitBody
	 *
	 * Constraint:
	 *     (var=VariableID initial=SimpleExpression semicolon?=';')
	 */
	protected void sequence_InitBody(ISerializationContext context, InitBody semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.ASSIGN_BODY__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.ASSIGN_BODY__VAR));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.INIT_BODY__INITIAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.INIT_BODY__INITIAL));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.ASSIGN_BODY__SEMICOLON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.ASSIGN_BODY__SEMICOLON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitBodyAccess().getVarVariableIDParserRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getInitBodyAccess().getInitialSimpleExpressionParserRuleCall_5_0(), semanticObject.getInitial());
		feeder.accept(grammarAccess.getInitBodyAccess().getSemicolonSemicolonKeyword_6_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns InitConstraint
	 *     InitConstraint returns InitConstraint
	 *
	 * Constraint:
	 *     (initExpression=SimpleExpression semicolon?=';'?)
	 */
	protected void sequence_InitConstraint(ISerializationContext context, InitConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns InvarConstraint
	 *     InvarConstraint returns InvarConstraint
	 *
	 * Constraint:
	 *     (invarExpression=SimpleExpression semicolon?=';'?)
	 */
	protected void sequence_InvarConstraint(ISerializationContext context, InvarConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns InvarSpecification
	 *     InvarSpecification returns InvarSpecification
	 *
	 * Constraint:
	 *     (invarSpec=NextExpression | (name=ID invarSpec=NextExpression semicolon?=';'?))
	 */
	protected void sequence_InvarSpecification(ISerializationContext context, InvarSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns IsaDeclaration
	 *     IsaDeclaration returns IsaDeclaration
	 *
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_IsaDeclaration(ISerializationContext context, IsaDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.ISA_DECLARATION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.ISA_DECLARATION__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsaDeclarationAccess().getIdIDTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns JusticeExpression
	 *     FairnessConstraint returns JusticeExpression
	 *     JusticeExpression returns JusticeExpression
	 *
	 * Constraint:
	 *     (justiceExpr=SimpleExpression semicolon?=';'?)
	 */
	protected void sequence_JusticeExpression(ISerializationContext context, JusticeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LTLExpression returns LTLExpression
	 *
	 * Constraint:
	 *     simpleExpression=SimpleExpression
	 */
	protected void sequence_LTLExpression(ISerializationContext context, LTLExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.LTL_EXPRESSION__SIMPLE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.LTL_EXPRESSION__SIMPLE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLTLExpressionAccess().getSimpleExpressionSimpleExpressionParserRuleCall_0(), semanticObject.getSimpleExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns LtlSpecification
	 *     LtlSpecification returns LtlSpecification
	 *
	 * Constraint:
	 *     ((nameId?='NAME' name=ID)? ltlExpression=LTLExpression semicolon?=';'?)
	 */
	protected void sequence_LtlSpecification(ISerializationContext context, LtlSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns AsyncrProcessType
	 *     ModuleType returns AsyncrProcessType
	 *
	 * Constraint:
	 *     (module=[Module|ID] ((params+=SimpleExpression | par=[VarBody|ID]) params+=SimpleExpression*)?)
	 */
	protected void sequence_ModuleType(ISerializationContext context, AsyncrProcessType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns SyncrProcessType
	 *     ModuleType returns SyncrProcessType
	 *
	 * Constraint:
	 *     (module=[Module|ID] ((params+=SimpleExpression | par=[VarBody|ID]) params+=SimpleExpression*)?)
	 */
	protected void sequence_ModuleType(ISerializationContext context, SyncrProcessType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns Module
	 *
	 * Constraint:
	 *     (name=ID (params+=FormalParameter params+=FormalParameter*)? moduleElement+=ModuleElement*)
	 */
	protected void sequence_Module(ISerializationContext context, org.xtext.nusmv.language.nuSMV.Module semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssignBody returns NextBody
	 *     NextBody returns NextBody
	 *
	 * Constraint:
	 *     (var=VariableID next=NextExpression semicolon?=';')
	 */
	protected void sequence_NextBody(ISerializationContext context, NextBody semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.ASSIGN_BODY__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.ASSIGN_BODY__VAR));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.NEXT_BODY__NEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.NEXT_BODY__NEXT));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.ASSIGN_BODY__SEMICOLON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.ASSIGN_BODY__SEMICOLON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNextBodyAccess().getVarVariableIDParserRuleCall_2_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getNextBodyAccess().getNextNextExpressionParserRuleCall_5_0(), semanticObject.getNext());
		feeder.accept(grammarAccess.getNextBodyAccess().getSemicolonSemicolonKeyword_6_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NextExpression returns NextExpression
	 *
	 * Constraint:
	 *     simpleExpression=SimpleExpression
	 */
	protected void sequence_NextExpression(ISerializationContext context, NextExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.NEXT_EXPRESSION__SIMPLE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.NEXT_EXPRESSION__SIMPLE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNextExpressionAccess().getSimpleExpressionSimpleExpressionParserRuleCall_0(), semanticObject.getSimpleExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Not
	 *     LTLbinExpression returns Not
	 *     LTLbinExpression.BinaryExpression_1_0 returns Not
	 *     ImpliesExpression returns Not
	 *     ImpliesExpression.BinaryExpression_1_0 returns Not
	 *     IffExpression returns Not
	 *     IffExpression.BinaryExpression_1_0 returns Not
	 *     OrExpression returns Not
	 *     OrExpression.BinaryExpression_1_0 returns Not
	 *     AndExpression returns Not
	 *     AndExpression.BinaryExpression_1_0 returns Not
	 *     ComparisonExpression returns Not
	 *     ComparisonExpression.BinaryExpression_1_0 returns Not
	 *     InExpression returns Not
	 *     InExpression.BinaryExpression_1_0 returns Not
	 *     UnionExpression returns Not
	 *     UnionExpression.BinaryExpression_1_0 returns Not
	 *     RightShift returns Not
	 *     RightShift.BinaryExpression_1_0 returns Not
	 *     LeftShift returns Not
	 *     LeftShift.BinaryExpression_1_0 returns Not
	 *     Minus returns Not
	 *     Minus.BinaryExpression_1_0 returns Not
	 *     Plus returns Not
	 *     Plus.BinaryExpression_1_0 returns Not
	 *     Mult returns Not
	 *     Mult.BinaryExpression_1_0 returns Not
	 *     Mod returns Not
	 *     Mod.BinaryExpression_1_0 returns Not
	 *     WordConcatenation returns Not
	 *     WordConcatenation.BinaryExpression_1_0 returns Not
	 *     Div returns Not
	 *     Div.BinaryExpression_1_0 returns Not
	 *     NotOrTerminalSimpleExpression returns Not
	 *
	 * Constraint:
	 *     exp=TerminalSimpleExpression
	 */
	protected void sequence_NotOrTerminalSimpleExpression(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.NOT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.NOT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotOrTerminalSimpleExpressionAccess().getExpTerminalSimpleExpressionParserRuleCall_0_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NuSmvModel returns NuSmvModel
	 *
	 * Constraint:
	 *     modules+=Module+
	 */
	protected void sequence_NuSmvModel(ISerializationContext context, NuSmvModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PSLExpression returns PSLExpression
	 *
	 * Constraint:
	 *     simpleExpression=SimpleExpression
	 */
	protected void sequence_PSLExpression(ISerializationContext context, PSLExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.PSL_EXPRESSION__SIMPLE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.PSL_EXPRESSION__SIMPLE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPSLExpressionAccess().getSimpleExpressionSimpleExpressionParserRuleCall_0(), semanticObject.getSimpleExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns PslSpecification
	 *     PslSpecification returns PslSpecification
	 *
	 * Constraint:
	 *     ((nameKeyWord?='NAME' name=ID)? pslExpression=PSLExpression semicolon?=';'?)
	 */
	protected void sequence_PslSpecification(ISerializationContext context, PslSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RTCTLExpression returns SingleRTCTLExpression
	 *
	 * Constraint:
	 *     (ctlExpression=CTLExpression | ctlExpression=FormalParameter)
	 */
	protected void sequence_RTCTLExpression(ISerializationContext context, SingleRTCTLExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RTCTLExpression returns UnaryRTCTLExpression
	 *
	 * Constraint:
	 *     ((unary='EBF' | unary='ABF' | unary='EBG' | unary='ABG') range=RangeExpression rctl=RTCTLExpression)
	 */
	protected void sequence_RTCTLExpression(ISerializationContext context, UnaryRTCTLExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RangeExpression returns RangeExpression
	 *
	 * Constraint:
	 *     (lower=NUMBER upper=NUMBER)
	 */
	protected void sequence_RangeExpression(ISerializationContext context, RangeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.RANGE_EXPRESSION__LOWER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.RANGE_EXPRESSION__LOWER));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.RANGE_EXPRESSION__UPPER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.RANGE_EXPRESSION__UPPER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeExpressionAccess().getLowerNUMBERParserRuleCall_0_0(), semanticObject.getLower());
		feeder.accept(grammarAccess.getRangeExpressionAccess().getUpperNUMBERParserRuleCall_2_0(), semanticObject.getUpper());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ArrayType
	 *     SimpleType returns ArrayType
	 *
	 * Constraint:
	 *     ((lowerBound=NUMBER | lowerBound=VariableID) (upperBound=NUMBER | upperBound=VariableID) type=SimpleType)
	 */
	protected void sequence_SimpleType(ISerializationContext context, ArrayType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns BooleanType
	 *     SimpleType returns BooleanType
	 *
	 * Constraint:
	 *     {BooleanType}
	 */
	protected void sequence_SimpleType(ISerializationContext context, BooleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns EnumType
	 *     SimpleType returns EnumType
	 *
	 * Constraint:
	 *     (val+=Val val+=Val*)
	 */
	protected void sequence_SimpleType(ISerializationContext context, EnumType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns IntervalType
	 *     SimpleType returns IntervalType
	 *
	 * Constraint:
	 *     ((low=NUMBER | low=VariableID) (high=NUMBER | high=VariableID))
	 */
	protected void sequence_SimpleType(ISerializationContext context, IntervalType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns SignedWordType
	 *     SimpleType returns SignedWordType
	 *
	 * Constraint:
	 *     signedNumber=NUMBER
	 */
	protected void sequence_SimpleType(ISerializationContext context, SignedWordType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.SIGNED_WORD_TYPE__SIGNED_NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.SIGNED_WORD_TYPE__SIGNED_NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleTypeAccess().getSignedNumberNUMBERParserRuleCall_3_1_2_0(), semanticObject.getSignedNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns UnsignedWordType
	 *     SimpleType returns UnsignedWordType
	 *
	 * Constraint:
	 *     uWordNumber=NUMBER
	 */
	protected void sequence_SimpleType(ISerializationContext context, UnsignedWordType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.UNSIGNED_WORD_TYPE__UWORD_NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.UNSIGNED_WORD_TYPE__UWORD_NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleTypeAccess().getUWordNumberNUMBERParserRuleCall_2_1_3_0(), semanticObject.getUWordNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns WordType
	 *     SimpleType returns WordType
	 *
	 * Constraint:
	 *     wordNumber=NUMBER
	 */
	protected void sequence_SimpleType(ISerializationContext context, WordType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.WORD_TYPE__WORD_NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.WORD_TYPE__WORD_NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleTypeAccess().getWordNumberNUMBERParserRuleCall_1_1_2_0(), semanticObject.getWordNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns IntervalExpression
	 *     LTLbinExpression returns IntervalExpression
	 *     LTLbinExpression.BinaryExpression_1_0 returns IntervalExpression
	 *     ImpliesExpression returns IntervalExpression
	 *     ImpliesExpression.BinaryExpression_1_0 returns IntervalExpression
	 *     IffExpression returns IntervalExpression
	 *     IffExpression.BinaryExpression_1_0 returns IntervalExpression
	 *     OrExpression returns IntervalExpression
	 *     OrExpression.BinaryExpression_1_0 returns IntervalExpression
	 *     AndExpression returns IntervalExpression
	 *     AndExpression.BinaryExpression_1_0 returns IntervalExpression
	 *     ComparisonExpression returns IntervalExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns IntervalExpression
	 *     InExpression returns IntervalExpression
	 *     InExpression.BinaryExpression_1_0 returns IntervalExpression
	 *     UnionExpression returns IntervalExpression
	 *     UnionExpression.BinaryExpression_1_0 returns IntervalExpression
	 *     RightShift returns IntervalExpression
	 *     RightShift.BinaryExpression_1_0 returns IntervalExpression
	 *     LeftShift returns IntervalExpression
	 *     LeftShift.BinaryExpression_1_0 returns IntervalExpression
	 *     Minus returns IntervalExpression
	 *     Minus.BinaryExpression_1_0 returns IntervalExpression
	 *     Plus returns IntervalExpression
	 *     Plus.BinaryExpression_1_0 returns IntervalExpression
	 *     Mult returns IntervalExpression
	 *     Mult.BinaryExpression_1_0 returns IntervalExpression
	 *     Mod returns IntervalExpression
	 *     Mod.BinaryExpression_1_0 returns IntervalExpression
	 *     WordConcatenation returns IntervalExpression
	 *     WordConcatenation.BinaryExpression_1_0 returns IntervalExpression
	 *     Div returns IntervalExpression
	 *     Div.BinaryExpression_1_0 returns IntervalExpression
	 *     NotOrTerminalSimpleExpression returns IntervalExpression
	 *     TerminalSimpleExpression returns IntervalExpression
	 *
	 * Constraint:
	 *     (lowerBound=NUMBER upperBound=NUMBER)
	 */
	protected void sequence_TerminalSimpleExpression(ISerializationContext context, IntervalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.INTERVAL_EXPRESSION__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.INTERVAL_EXPRESSION__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.INTERVAL_EXPRESSION__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.INTERVAL_EXPRESSION__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalSimpleExpressionAccess().getLowerBoundNUMBERParserRuleCall_14_1_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getTerminalSimpleExpressionAccess().getUpperBoundNUMBERParserRuleCall_14_3_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns ParsExpression
	 *     LTLbinExpression returns ParsExpression
	 *     LTLbinExpression.BinaryExpression_1_0 returns ParsExpression
	 *     ImpliesExpression returns ParsExpression
	 *     ImpliesExpression.BinaryExpression_1_0 returns ParsExpression
	 *     IffExpression returns ParsExpression
	 *     IffExpression.BinaryExpression_1_0 returns ParsExpression
	 *     OrExpression returns ParsExpression
	 *     OrExpression.BinaryExpression_1_0 returns ParsExpression
	 *     AndExpression returns ParsExpression
	 *     AndExpression.BinaryExpression_1_0 returns ParsExpression
	 *     ComparisonExpression returns ParsExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns ParsExpression
	 *     InExpression returns ParsExpression
	 *     InExpression.BinaryExpression_1_0 returns ParsExpression
	 *     UnionExpression returns ParsExpression
	 *     UnionExpression.BinaryExpression_1_0 returns ParsExpression
	 *     RightShift returns ParsExpression
	 *     RightShift.BinaryExpression_1_0 returns ParsExpression
	 *     LeftShift returns ParsExpression
	 *     LeftShift.BinaryExpression_1_0 returns ParsExpression
	 *     Minus returns ParsExpression
	 *     Minus.BinaryExpression_1_0 returns ParsExpression
	 *     Plus returns ParsExpression
	 *     Plus.BinaryExpression_1_0 returns ParsExpression
	 *     Mult returns ParsExpression
	 *     Mult.BinaryExpression_1_0 returns ParsExpression
	 *     Mod returns ParsExpression
	 *     Mod.BinaryExpression_1_0 returns ParsExpression
	 *     WordConcatenation returns ParsExpression
	 *     WordConcatenation.BinaryExpression_1_0 returns ParsExpression
	 *     Div returns ParsExpression
	 *     Div.BinaryExpression_1_0 returns ParsExpression
	 *     NotOrTerminalSimpleExpression returns ParsExpression
	 *     TerminalSimpleExpression returns ParsExpression
	 *
	 * Constraint:
	 *     (isNext='next'? simpleExpression=SimpleExpression)
	 */
	protected void sequence_TerminalSimpleExpression(ISerializationContext context, ParsExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns SetElementExpression
	 *     LTLbinExpression returns SetElementExpression
	 *     LTLbinExpression.BinaryExpression_1_0 returns SetElementExpression
	 *     ImpliesExpression returns SetElementExpression
	 *     ImpliesExpression.BinaryExpression_1_0 returns SetElementExpression
	 *     IffExpression returns SetElementExpression
	 *     IffExpression.BinaryExpression_1_0 returns SetElementExpression
	 *     OrExpression returns SetElementExpression
	 *     OrExpression.BinaryExpression_1_0 returns SetElementExpression
	 *     AndExpression returns SetElementExpression
	 *     AndExpression.BinaryExpression_1_0 returns SetElementExpression
	 *     ComparisonExpression returns SetElementExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns SetElementExpression
	 *     InExpression returns SetElementExpression
	 *     InExpression.BinaryExpression_1_0 returns SetElementExpression
	 *     UnionExpression returns SetElementExpression
	 *     UnionExpression.BinaryExpression_1_0 returns SetElementExpression
	 *     RightShift returns SetElementExpression
	 *     RightShift.BinaryExpression_1_0 returns SetElementExpression
	 *     LeftShift returns SetElementExpression
	 *     LeftShift.BinaryExpression_1_0 returns SetElementExpression
	 *     Minus returns SetElementExpression
	 *     Minus.BinaryExpression_1_0 returns SetElementExpression
	 *     Plus returns SetElementExpression
	 *     Plus.BinaryExpression_1_0 returns SetElementExpression
	 *     Mult returns SetElementExpression
	 *     Mult.BinaryExpression_1_0 returns SetElementExpression
	 *     Mod returns SetElementExpression
	 *     Mod.BinaryExpression_1_0 returns SetElementExpression
	 *     WordConcatenation returns SetElementExpression
	 *     WordConcatenation.BinaryExpression_1_0 returns SetElementExpression
	 *     Div returns SetElementExpression
	 *     Div.BinaryExpression_1_0 returns SetElementExpression
	 *     NotOrTerminalSimpleExpression returns SetElementExpression
	 *     TerminalSimpleExpression returns SetElementExpression
	 *
	 * Constraint:
	 *     val=[Val|ID]
	 */
	protected void sequence_TerminalSimpleExpression(ISerializationContext context, SetElementExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.SET_ELEMENT_EXPRESSION__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.SET_ELEMENT_EXPRESSION__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalSimpleExpressionAccess().getValValIDTerminalRuleCall_5_1_0_1(), semanticObject.eGet(NuSMVPackage.Literals.SET_ELEMENT_EXPRESSION__VAL, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns SetExpression
	 *     LTLbinExpression returns SetExpression
	 *     LTLbinExpression.BinaryExpression_1_0 returns SetExpression
	 *     ImpliesExpression returns SetExpression
	 *     ImpliesExpression.BinaryExpression_1_0 returns SetExpression
	 *     IffExpression returns SetExpression
	 *     IffExpression.BinaryExpression_1_0 returns SetExpression
	 *     OrExpression returns SetExpression
	 *     OrExpression.BinaryExpression_1_0 returns SetExpression
	 *     AndExpression returns SetExpression
	 *     AndExpression.BinaryExpression_1_0 returns SetExpression
	 *     ComparisonExpression returns SetExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns SetExpression
	 *     InExpression returns SetExpression
	 *     InExpression.BinaryExpression_1_0 returns SetExpression
	 *     UnionExpression returns SetExpression
	 *     UnionExpression.BinaryExpression_1_0 returns SetExpression
	 *     RightShift returns SetExpression
	 *     RightShift.BinaryExpression_1_0 returns SetExpression
	 *     LeftShift returns SetExpression
	 *     LeftShift.BinaryExpression_1_0 returns SetExpression
	 *     Minus returns SetExpression
	 *     Minus.BinaryExpression_1_0 returns SetExpression
	 *     Plus returns SetExpression
	 *     Plus.BinaryExpression_1_0 returns SetExpression
	 *     Mult returns SetExpression
	 *     Mult.BinaryExpression_1_0 returns SetExpression
	 *     Mod returns SetExpression
	 *     Mod.BinaryExpression_1_0 returns SetExpression
	 *     WordConcatenation returns SetExpression
	 *     WordConcatenation.BinaryExpression_1_0 returns SetExpression
	 *     Div returns SetExpression
	 *     Div.BinaryExpression_1_0 returns SetExpression
	 *     NotOrTerminalSimpleExpression returns SetExpression
	 *     TerminalSimpleExpression returns SetExpression
	 *
	 * Constraint:
	 *     (setElement+=SimpleExpression setElement+=SimpleExpression*)
	 */
	protected void sequence_TerminalSimpleExpression(ISerializationContext context, SetExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns SetValueParameter
	 *     LTLbinExpression returns SetValueParameter
	 *     LTLbinExpression.BinaryExpression_1_0 returns SetValueParameter
	 *     ImpliesExpression returns SetValueParameter
	 *     ImpliesExpression.BinaryExpression_1_0 returns SetValueParameter
	 *     IffExpression returns SetValueParameter
	 *     IffExpression.BinaryExpression_1_0 returns SetValueParameter
	 *     OrExpression returns SetValueParameter
	 *     OrExpression.BinaryExpression_1_0 returns SetValueParameter
	 *     AndExpression returns SetValueParameter
	 *     AndExpression.BinaryExpression_1_0 returns SetValueParameter
	 *     ComparisonExpression returns SetValueParameter
	 *     ComparisonExpression.BinaryExpression_1_0 returns SetValueParameter
	 *     InExpression returns SetValueParameter
	 *     InExpression.BinaryExpression_1_0 returns SetValueParameter
	 *     UnionExpression returns SetValueParameter
	 *     UnionExpression.BinaryExpression_1_0 returns SetValueParameter
	 *     RightShift returns SetValueParameter
	 *     RightShift.BinaryExpression_1_0 returns SetValueParameter
	 *     LeftShift returns SetValueParameter
	 *     LeftShift.BinaryExpression_1_0 returns SetValueParameter
	 *     Minus returns SetValueParameter
	 *     Minus.BinaryExpression_1_0 returns SetValueParameter
	 *     Plus returns SetValueParameter
	 *     Plus.BinaryExpression_1_0 returns SetValueParameter
	 *     Mult returns SetValueParameter
	 *     Mult.BinaryExpression_1_0 returns SetValueParameter
	 *     Mod returns SetValueParameter
	 *     Mod.BinaryExpression_1_0 returns SetValueParameter
	 *     WordConcatenation returns SetValueParameter
	 *     WordConcatenation.BinaryExpression_1_0 returns SetValueParameter
	 *     Div returns SetValueParameter
	 *     Div.BinaryExpression_1_0 returns SetValueParameter
	 *     NotOrTerminalSimpleExpression returns SetValueParameter
	 *     TerminalSimpleExpression returns SetValueParameter
	 *
	 * Constraint:
	 *     valparam=[FormalParameter|ID]
	 */
	protected void sequence_TerminalSimpleExpression(ISerializationContext context, SetValueParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.SET_VALUE_PARAMETER__VALPARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.SET_VALUE_PARAMETER__VALPARAM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalSimpleExpressionAccess().getValparamFormalParameterIDTerminalRuleCall_6_1_0_1(), semanticObject.eGet(NuSMVPackage.Literals.SET_VALUE_PARAMETER__VALPARAM, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns ToInt
	 *     LTLbinExpression returns ToInt
	 *     LTLbinExpression.BinaryExpression_1_0 returns ToInt
	 *     ImpliesExpression returns ToInt
	 *     ImpliesExpression.BinaryExpression_1_0 returns ToInt
	 *     IffExpression returns ToInt
	 *     IffExpression.BinaryExpression_1_0 returns ToInt
	 *     OrExpression returns ToInt
	 *     OrExpression.BinaryExpression_1_0 returns ToInt
	 *     AndExpression returns ToInt
	 *     AndExpression.BinaryExpression_1_0 returns ToInt
	 *     ComparisonExpression returns ToInt
	 *     ComparisonExpression.BinaryExpression_1_0 returns ToInt
	 *     InExpression returns ToInt
	 *     InExpression.BinaryExpression_1_0 returns ToInt
	 *     UnionExpression returns ToInt
	 *     UnionExpression.BinaryExpression_1_0 returns ToInt
	 *     RightShift returns ToInt
	 *     RightShift.BinaryExpression_1_0 returns ToInt
	 *     LeftShift returns ToInt
	 *     LeftShift.BinaryExpression_1_0 returns ToInt
	 *     Minus returns ToInt
	 *     Minus.BinaryExpression_1_0 returns ToInt
	 *     Plus returns ToInt
	 *     Plus.BinaryExpression_1_0 returns ToInt
	 *     Mult returns ToInt
	 *     Mult.BinaryExpression_1_0 returns ToInt
	 *     Mod returns ToInt
	 *     Mod.BinaryExpression_1_0 returns ToInt
	 *     WordConcatenation returns ToInt
	 *     WordConcatenation.BinaryExpression_1_0 returns ToInt
	 *     Div returns ToInt
	 *     Div.BinaryExpression_1_0 returns ToInt
	 *     NotOrTerminalSimpleExpression returns ToInt
	 *     TerminalSimpleExpression returns ToInt
	 *
	 * Constraint:
	 *     arg=SimpleExpression
	 */
	protected void sequence_TerminalSimpleExpression(ISerializationContext context, ToInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.TO_INT__ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.TO_INT__ARG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalSimpleExpressionAccess().getArgSimpleExpressionParserRuleCall_17_3_0(), semanticObject.getArg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns UnaryExpression
	 *     LTLbinExpression returns UnaryExpression
	 *     LTLbinExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     ImpliesExpression returns UnaryExpression
	 *     ImpliesExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     IffExpression returns UnaryExpression
	 *     IffExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     OrExpression returns UnaryExpression
	 *     OrExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     AndExpression returns UnaryExpression
	 *     AndExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     ComparisonExpression returns UnaryExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     InExpression returns UnaryExpression
	 *     InExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     UnionExpression returns UnaryExpression
	 *     UnionExpression.BinaryExpression_1_0 returns UnaryExpression
	 *     RightShift returns UnaryExpression
	 *     RightShift.BinaryExpression_1_0 returns UnaryExpression
	 *     LeftShift returns UnaryExpression
	 *     LeftShift.BinaryExpression_1_0 returns UnaryExpression
	 *     Minus returns UnaryExpression
	 *     Minus.BinaryExpression_1_0 returns UnaryExpression
	 *     Plus returns UnaryExpression
	 *     Plus.BinaryExpression_1_0 returns UnaryExpression
	 *     Mult returns UnaryExpression
	 *     Mult.BinaryExpression_1_0 returns UnaryExpression
	 *     Mod returns UnaryExpression
	 *     Mod.BinaryExpression_1_0 returns UnaryExpression
	 *     WordConcatenation returns UnaryExpression
	 *     WordConcatenation.BinaryExpression_1_0 returns UnaryExpression
	 *     Div returns UnaryExpression
	 *     Div.BinaryExpression_1_0 returns UnaryExpression
	 *     NotOrTerminalSimpleExpression returns UnaryExpression
	 *     TerminalSimpleExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             operator='-' | 
	 *             operator='+' | 
	 *             operator='EG' | 
	 *             operator='EX' | 
	 *             operator='EF' | 
	 *             operator='AG' | 
	 *             operator='AX' | 
	 *             operator='AF' | 
	 *             operator='X' | 
	 *             operator='G' | 
	 *             operator='F' | 
	 *             operator='Y' | 
	 *             operator='Z' | 
	 *             operator='H' | 
	 *             operator='O'
	 *         ) 
	 *         simpleExpression=SimpleExpression
	 *     )
	 */
	protected void sequence_TerminalSimpleExpression(ISerializationContext context, UnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns UnaryFunctionExpression
	 *     LTLbinExpression returns UnaryFunctionExpression
	 *     LTLbinExpression.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     ImpliesExpression returns UnaryFunctionExpression
	 *     ImpliesExpression.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     IffExpression returns UnaryFunctionExpression
	 *     IffExpression.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     OrExpression returns UnaryFunctionExpression
	 *     OrExpression.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     AndExpression returns UnaryFunctionExpression
	 *     AndExpression.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     ComparisonExpression returns UnaryFunctionExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     InExpression returns UnaryFunctionExpression
	 *     InExpression.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     UnionExpression returns UnaryFunctionExpression
	 *     UnionExpression.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     RightShift returns UnaryFunctionExpression
	 *     RightShift.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     LeftShift returns UnaryFunctionExpression
	 *     LeftShift.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     Minus returns UnaryFunctionExpression
	 *     Minus.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     Plus returns UnaryFunctionExpression
	 *     Plus.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     Mult returns UnaryFunctionExpression
	 *     Mult.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     Mod returns UnaryFunctionExpression
	 *     Mod.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     WordConcatenation returns UnaryFunctionExpression
	 *     WordConcatenation.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     Div returns UnaryFunctionExpression
	 *     Div.BinaryExpression_1_0 returns UnaryFunctionExpression
	 *     NotOrTerminalSimpleExpression returns UnaryFunctionExpression
	 *     TerminalSimpleExpression returns UnaryFunctionExpression
	 *
	 * Constraint:
	 *     ((function='word1' | function='bool') arg=SimpleExpression)
	 */
	protected void sequence_TerminalSimpleExpression(ISerializationContext context, UnaryFunctionExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns UntilCTLexpression
	 *     LTLbinExpression returns UntilCTLexpression
	 *     LTLbinExpression.BinaryExpression_1_0 returns UntilCTLexpression
	 *     ImpliesExpression returns UntilCTLexpression
	 *     ImpliesExpression.BinaryExpression_1_0 returns UntilCTLexpression
	 *     IffExpression returns UntilCTLexpression
	 *     IffExpression.BinaryExpression_1_0 returns UntilCTLexpression
	 *     OrExpression returns UntilCTLexpression
	 *     OrExpression.BinaryExpression_1_0 returns UntilCTLexpression
	 *     AndExpression returns UntilCTLexpression
	 *     AndExpression.BinaryExpression_1_0 returns UntilCTLexpression
	 *     ComparisonExpression returns UntilCTLexpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns UntilCTLexpression
	 *     InExpression returns UntilCTLexpression
	 *     InExpression.BinaryExpression_1_0 returns UntilCTLexpression
	 *     UnionExpression returns UntilCTLexpression
	 *     UnionExpression.BinaryExpression_1_0 returns UntilCTLexpression
	 *     RightShift returns UntilCTLexpression
	 *     RightShift.BinaryExpression_1_0 returns UntilCTLexpression
	 *     LeftShift returns UntilCTLexpression
	 *     LeftShift.BinaryExpression_1_0 returns UntilCTLexpression
	 *     Minus returns UntilCTLexpression
	 *     Minus.BinaryExpression_1_0 returns UntilCTLexpression
	 *     Plus returns UntilCTLexpression
	 *     Plus.BinaryExpression_1_0 returns UntilCTLexpression
	 *     Mult returns UntilCTLexpression
	 *     Mult.BinaryExpression_1_0 returns UntilCTLexpression
	 *     Mod returns UntilCTLexpression
	 *     Mod.BinaryExpression_1_0 returns UntilCTLexpression
	 *     WordConcatenation returns UntilCTLexpression
	 *     WordConcatenation.BinaryExpression_1_0 returns UntilCTLexpression
	 *     Div returns UntilCTLexpression
	 *     Div.BinaryExpression_1_0 returns UntilCTLexpression
	 *     NotOrTerminalSimpleExpression returns UntilCTLexpression
	 *     TerminalSimpleExpression returns UntilCTLexpression
	 *
	 * Constraint:
	 *     ((ea='E' | ea='A') arg=LTLbinExpression)
	 */
	protected void sequence_TerminalSimpleExpression(ISerializationContext context, UntilCTLexpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns ValueExpression
	 *     LTLbinExpression returns ValueExpression
	 *     LTLbinExpression.BinaryExpression_1_0 returns ValueExpression
	 *     ImpliesExpression returns ValueExpression
	 *     ImpliesExpression.BinaryExpression_1_0 returns ValueExpression
	 *     IffExpression returns ValueExpression
	 *     IffExpression.BinaryExpression_1_0 returns ValueExpression
	 *     OrExpression returns ValueExpression
	 *     OrExpression.BinaryExpression_1_0 returns ValueExpression
	 *     AndExpression returns ValueExpression
	 *     AndExpression.BinaryExpression_1_0 returns ValueExpression
	 *     ComparisonExpression returns ValueExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns ValueExpression
	 *     InExpression returns ValueExpression
	 *     InExpression.BinaryExpression_1_0 returns ValueExpression
	 *     UnionExpression returns ValueExpression
	 *     UnionExpression.BinaryExpression_1_0 returns ValueExpression
	 *     RightShift returns ValueExpression
	 *     RightShift.BinaryExpression_1_0 returns ValueExpression
	 *     LeftShift returns ValueExpression
	 *     LeftShift.BinaryExpression_1_0 returns ValueExpression
	 *     Minus returns ValueExpression
	 *     Minus.BinaryExpression_1_0 returns ValueExpression
	 *     Plus returns ValueExpression
	 *     Plus.BinaryExpression_1_0 returns ValueExpression
	 *     Mult returns ValueExpression
	 *     Mult.BinaryExpression_1_0 returns ValueExpression
	 *     Mod returns ValueExpression
	 *     Mod.BinaryExpression_1_0 returns ValueExpression
	 *     WordConcatenation returns ValueExpression
	 *     WordConcatenation.BinaryExpression_1_0 returns ValueExpression
	 *     Div returns ValueExpression
	 *     Div.BinaryExpression_1_0 returns ValueExpression
	 *     NotOrTerminalSimpleExpression returns ValueExpression
	 *     TerminalSimpleExpression returns ValueExpression
	 *
	 * Constraint:
	 *     (
	 *         (value=VariableID array+=NUMBER*) | 
	 *         value=ID | 
	 *         value=NUMBER | 
	 *         value='TRUE' | 
	 *         value='FALSE' | 
	 *         value='self'
	 *     )
	 */
	protected void sequence_TerminalSimpleExpression(ISerializationContext context, ValueExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns Var
	 *     LTLbinExpression returns Var
	 *     LTLbinExpression.BinaryExpression_1_0 returns Var
	 *     ImpliesExpression returns Var
	 *     ImpliesExpression.BinaryExpression_1_0 returns Var
	 *     IffExpression returns Var
	 *     IffExpression.BinaryExpression_1_0 returns Var
	 *     OrExpression returns Var
	 *     OrExpression.BinaryExpression_1_0 returns Var
	 *     AndExpression returns Var
	 *     AndExpression.BinaryExpression_1_0 returns Var
	 *     ComparisonExpression returns Var
	 *     ComparisonExpression.BinaryExpression_1_0 returns Var
	 *     InExpression returns Var
	 *     InExpression.BinaryExpression_1_0 returns Var
	 *     UnionExpression returns Var
	 *     UnionExpression.BinaryExpression_1_0 returns Var
	 *     RightShift returns Var
	 *     RightShift.BinaryExpression_1_0 returns Var
	 *     LeftShift returns Var
	 *     LeftShift.BinaryExpression_1_0 returns Var
	 *     Minus returns Var
	 *     Minus.BinaryExpression_1_0 returns Var
	 *     Plus returns Var
	 *     Plus.BinaryExpression_1_0 returns Var
	 *     Mult returns Var
	 *     Mult.BinaryExpression_1_0 returns Var
	 *     Mod returns Var
	 *     Mod.BinaryExpression_1_0 returns Var
	 *     WordConcatenation returns Var
	 *     WordConcatenation.BinaryExpression_1_0 returns Var
	 *     Div returns Var
	 *     Div.BinaryExpression_1_0 returns Var
	 *     NotOrTerminalSimpleExpression returns Var
	 *     TerminalSimpleExpression returns Var
	 *
	 * Constraint:
	 *     (value=[VarBody|ID] (dotted=TerminalSimpleExpression | array+=NUMBER+)?)
	 */
	protected void sequence_TerminalSimpleExpression(ISerializationContext context, Var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleExpression returns WordExpression
	 *     LTLbinExpression returns WordExpression
	 *     LTLbinExpression.BinaryExpression_1_0 returns WordExpression
	 *     ImpliesExpression returns WordExpression
	 *     ImpliesExpression.BinaryExpression_1_0 returns WordExpression
	 *     IffExpression returns WordExpression
	 *     IffExpression.BinaryExpression_1_0 returns WordExpression
	 *     OrExpression returns WordExpression
	 *     OrExpression.BinaryExpression_1_0 returns WordExpression
	 *     AndExpression returns WordExpression
	 *     AndExpression.BinaryExpression_1_0 returns WordExpression
	 *     ComparisonExpression returns WordExpression
	 *     ComparisonExpression.BinaryExpression_1_0 returns WordExpression
	 *     InExpression returns WordExpression
	 *     InExpression.BinaryExpression_1_0 returns WordExpression
	 *     UnionExpression returns WordExpression
	 *     UnionExpression.BinaryExpression_1_0 returns WordExpression
	 *     RightShift returns WordExpression
	 *     RightShift.BinaryExpression_1_0 returns WordExpression
	 *     LeftShift returns WordExpression
	 *     LeftShift.BinaryExpression_1_0 returns WordExpression
	 *     Minus returns WordExpression
	 *     Minus.BinaryExpression_1_0 returns WordExpression
	 *     Plus returns WordExpression
	 *     Plus.BinaryExpression_1_0 returns WordExpression
	 *     Mult returns WordExpression
	 *     Mult.BinaryExpression_1_0 returns WordExpression
	 *     Mod returns WordExpression
	 *     Mod.BinaryExpression_1_0 returns WordExpression
	 *     WordConcatenation returns WordExpression
	 *     WordConcatenation.BinaryExpression_1_0 returns WordExpression
	 *     Div returns WordExpression
	 *     Div.BinaryExpression_1_0 returns WordExpression
	 *     NotOrTerminalSimpleExpression returns WordExpression
	 *     TerminalSimpleExpression returns WordExpression
	 *
	 * Constraint:
	 *     value=WORD
	 */
	protected void sequence_TerminalSimpleExpression(ISerializationContext context, WordExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.WORD_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.WORD_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalSimpleExpressionAccess().getValueWORDTerminalRuleCall_13_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns TransConstraint
	 *     TransConstraint returns TransConstraint
	 *
	 * Constraint:
	 *     (transExpression=SimpleExpression semicolon?=';'?)
	 */
	protected void sequence_TransConstraint(ISerializationContext context, TransConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Val returns Val
	 *
	 * Constraint:
	 *     (name=ID | num=NUMBER)?
	 */
	protected void sequence_Val(ISerializationContext context, Val semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssignBody returns VarBodyAssign
	 *     VarBodyAssign returns VarBodyAssign
	 *
	 * Constraint:
	 *     (var=VariableID assignment=SimpleExpression semicolon?=';')
	 */
	protected void sequence_VarBodyAssign(ISerializationContext context, VarBodyAssign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.ASSIGN_BODY__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.ASSIGN_BODY__VAR));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.VAR_BODY_ASSIGN__ASSIGNMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.VAR_BODY_ASSIGN__ASSIGNMENT));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.ASSIGN_BODY__SEMICOLON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.ASSIGN_BODY__SEMICOLON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarBodyAssignAccess().getVarVariableIDParserRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getVarBodyAssignAccess().getAssignmentSimpleExpressionParserRuleCall_2_0(), semanticObject.getAssignment());
		feeder.accept(grammarAccess.getVarBodyAssignAccess().getSemicolonSemicolonKeyword_3_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarBody returns VarBody
	 *
	 * Constraint:
	 *     (name=ID type=Type semicolon?=';')
	 */
	protected void sequence_VarBody(ISerializationContext context, VarBody semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.VAR_BODY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.VAR_BODY__NAME));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.VAR_BODY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.VAR_BODY__TYPE));
			if (transientValues.isValueTransient(semanticObject, NuSMVPackage.Literals.VAR_BODY__SEMICOLON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NuSMVPackage.Literals.VAR_BODY__SEMICOLON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarBodyAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVarBodyAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVarBodyAccess().getSemicolonSemicolonKeyword_3_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns VariableDeclaration
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     vars+=VarBody*
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
